name: Full Audit - Supabase Edge Functions

on:
  workflow_dispatch:
    inputs:
      fail_on_404:
        description: "Fail workflow if any function is NOT_DEPLOYED (404/NOT_FOUND)"
        required: true
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      fail_on_boot:
        description: "Fail workflow if any function appears to have BOOT_ERROR (runtime/module error)"
        required: true
        default: "false"
        type: choice
        options:
          - "true"
          - "false"
      concurrency_limit:
        description: "Max concurrent checks (1..20). Lower = safer, higher = faster."
        required: true
        default: "8"
        type: choice
        options:
          - "1"
          - "2"
          - "4"
          - "6"
          - "8"
          - "10"
          - "12"
          - "16"
          - "20"

  # OPTIONAL: enable when ready
  # schedule:
  #   - cron: "*/30 * * * *"

concurrency:
  group: functions-full-audit
  cancel-in-progress: true

jobs:
  audit:
    runs-on: ubuntu-latest
    env:
      # !!! Set these in GitHub Secrets (recommended)
      # SUPABASE_URL: https://<project_ref>.supabase.co
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      AUDIT_ORIGIN: https://gorbova.lovable.app

    steps:
      - uses: actions/checkout@v4

      - name: Guard - required env
        run: |
          set -euo pipefail
          if [ -z "${SUPABASE_URL:-}" ]; then
            echo "::error::Missing SUPABASE_URL. Set GitHub Secret SUPABASE_URL=https://<project_ref>.supabase.co"
            exit 1
          fi
          echo "SUPABASE_URL=$SUPABASE_URL"
          echo "GITHUB_SHA=${GITHUB_SHA}"
          echo "GITHUB_RUN_ID=${GITHUB_RUN_ID}"
          echo "UTC_NOW=$(date -u '+%Y-%m-%d %H:%M:%S UTC')"

      - name: Build functions list (repo)
        run: |
          set -euo pipefail
          mkdir -p audit_out
          find supabase/functions -mindepth 1 -maxdepth 1 -type d -printf "%f\n" | sort > audit_out/functions.list
          echo "TOTAL_FUNCTIONS=$(wc -l < audit_out/functions.list)" | tee audit_out/summary.txt
          echo "Total functions in repo: $(wc -l < audit_out/functions.list)"
          head -n 50 audit_out/functions.list > audit_out/functions.list.head50 || true

      - name: Run full audit (OPTIONS + POST)
        env:
          FAIL_ON_404: ${{ inputs.fail_on_404 }}
          FAIL_ON_BOOT: ${{ inputs.fail_on_boot }}
          CONCURRENCY_LIMIT: ${{ inputs.concurrency_limit }}
        run: |
          set -euo pipefail

          LIST="audit_out/functions.list"
          NOW="$(date -u +%Y%m%d-%H%M%S)"
          LOG="audit_out/functions-audit-$NOW.log"
          JSON="audit_out/functions-audit-$NOW.json"

          echo "=== FULL AUDIT STARTED ===" | tee "$LOG"
          echo "UTC: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" | tee -a "$LOG"
          echo "SUPABASE_URL: $SUPABASE_URL" | tee -a "$LOG"
          echo "ORIGIN: $AUDIT_ORIGIN" | tee -a "$LOG"
          echo "fail_on_404=$FAIL_ON_404 fail_on_boot=$FAIL_ON_BOOT concurrency_limit=$CONCURRENCY_LIMIT" | tee -a "$LOG"
          echo "Total in repo: $(wc -l < "$LIST")" | tee -a "$LOG"
          echo "" | tee -a "$LOG"

          # Worker script (one function)
          cat > audit_out/_audit_one.sh <<'SH'
          #!/usr/bin/env bash
          set -euo pipefail

          func="$1"

          # --- OPTIONS preflight ---
          OPT_RAW="$(curl -s -i -m 10 -X OPTIONS \
            -H "Origin: ${AUDIT_ORIGIN}" \
            -H "Access-Control-Request-Method: POST" \
            -H "Access-Control-Request-Headers: content-type,authorization,x-supabase-client-platform" \
            "${SUPABASE_URL}/functions/v1/${func}" 2>&1 || true)"

          OPT_HTTP="$(echo "$OPT_RAW" | head -n 1 | awk '{print $2}' | tr -d '\r')"
          OPT_ALLOW_HEADERS="$(echo "$OPT_RAW" | tr -d '\r' | awk 'BEGIN{IGNORECASE=1} /^access-control-allow-headers:/{sub(/^access-control-allow-headers:[ ]*/,""); print; exit}')"
          OPT_ALLOW_METHODS="$(echo "$OPT_RAW" | tr -d '\r' | awk 'BEGIN{IGNORECASE=1} /^access-control-allow-methods:/{sub(/^access-control-allow-methods:[ ]*/,""); print; exit}')"

          # --- POST ping existence ---
          POST_RAW="$(curl -s -w "\n%{http_code}" -m 15 \
            -X POST -H "Content-Type: application/json" \
            -d '{"ping":true}' \
            "${SUPABASE_URL}/functions/v1/${func}" 2>&1 || true)"

          POST_HTTP="$(echo "$POST_RAW" | tail -1 | tr -d '\r')"
          POST_BODY="$(echo "$POST_RAW" | sed '$d' | head -c 1200 | tr '\n' ' ')"

          # --- classify ---
          status="OK"

          # connection failure
          if [ "${POST_HTTP}" = "000" ] || echo "$POST_BODY" | grep -qiE "connection.*failed|timed out|Could not resolve|TLS"; then
            status="CONNECTION_FAILED"
          # not deployed
          elif [ "${POST_HTTP}" = "404" ] || echo "$POST_BODY" | grep -q '"code":"NOT_FOUND"'; then
            status="NOT_DEPLOYED"
          else
            # possible boot error (heuristic)
            if echo "$POST_BODY" | grep -qiE "BOOT_ERROR|Uncaught|Module not found|Cannot find module|SyntaxError|TypeError|ReferenceError|Internal Server Error"; then
              # Only mark BOOT_ERROR if server responded 500-ish or body looks like runtime crash
              if [ "${POST_HTTP}" = "500" ] || echo "$POST_BODY" | grep -qiE "BOOT_ERROR|Module not found|SyntaxError"; then
                status="BOOT_ERROR"
              fi
            fi

            # CORS check (warning only if function exists)
            if [ "${OPT_HTTP}" = "404" ] || [ -z "${OPT_HTTP}" ]; then
              # OPTIONS path not responding or function missing on OPTIONS
              if [ "$status" = "OK" ]; then
                status="CORS_404"
              fi
            else
              # If allow-headers is missing x-supabase-client-* => warning
              if [ "$status" = "OK" ]; then
                if [ -z "$OPT_ALLOW_HEADERS" ]; then
                  status="CORS_WARNING"
                elif ! echo "$OPT_ALLOW_HEADERS" | grep -qi "x-supabase-client-platform"; then
                  status="CORS_WARNING"
                fi
              fi
            fi
          fi

          # Print compact line for log consumption
          echo "${func}|${OPT_HTTP:-}|${POST_HTTP:-}|${status}|${OPT_ALLOW_METHODS:-}|${OPT_ALLOW_HEADERS:-}|${POST_BODY}"
          SH
          chmod +x audit_out/_audit_one.sh

          # Prepare JSON header
          echo "[" > "$JSON"
          first=1

          # Run with controlled concurrency
          export SUPABASE_URL AUDIT_ORIGIN

          # shellcheck disable=SC2016
          run_one() {
            local f="$1"
            audit_out/_audit_one.sh "$f"
          }

          # Read list and parallelize
          C_LIMIT="${CONCURRENCY_LIMIT:-8}"
          if ! [[ "$C_LIMIT" =~ ^[0-9]+$ ]]; then C_LIMIT=8; fi
          if [ "$C_LIMIT" -lt 1 ]; then C_LIMIT=1; fi
          if [ "$C_LIMIT" -gt 20 ]; then C_LIMIT=20; fi

          echo "Concurrency limit: $C_LIMIT" | tee -a "$LOG"

          # Use xargs -P for parallel audit
          export -f run_one || true

          # xargs will call subshell, so call script directly
          mapfile -t lines < <(cat "$LIST" | xargs -I{} -P "$C_LIMIT" bash audit_out/_audit_one.sh "{}")

          # Summaries
          not_deployed=0
          boot_error=0
          cors_warn=0
          cors_404=0
          conn_failed=0
          ok=0

          for line in "${lines[@]}"; do
            IFS='|' read -r name opt_http post_http st allow_methods allow_headers snippet <<<"$line"

            # log line
            printf "%-40s OPT:%-4s POST:%-4s %-16s\n" "$name" "${opt_http:-}" "${post_http:-}" "$st" | tee -a "$LOG"

            # counters
            case "$st" in
              OK) ok=$((ok+1));;
              NOT_DEPLOYED) not_deployed=$((not_deployed+1));;
              BOOT_ERROR) boot_error=$((boot_error+1));;
              CORS_WARNING) cors_warn=$((cors_warn+1));;
              CORS_404) cors_404=$((cors_404+1));;
              CONNECTION_FAILED) conn_failed=$((conn_failed+1));;
              *) ;;
            esac

            # JSON entry
            esc_snippet="$(echo "${snippet:-}" | sed 's/\\/\\\\/g; s/"/\\"/g')"
            esc_hdrs="$(echo "${allow_headers:-}" | sed 's/\\/\\\\/g; s/"/\\"/g')"
            esc_meth="$(echo "${allow_methods:-}" | sed 's/\\/\\\\/g; s/"/\\"/g')"

            entry="{\"name\":\"$name\",\"options_http\":\"${opt_http:-}\",\"post_http\":\"${post_http:-}\",\"status\":\"$st\",\"allow_methods\":\"$esc_meth\",\"allow_headers\":\"$esc_hdrs\",\"post_body_snippet\":\"$esc_snippet\"}"

            if [ $first -eq 1 ]; then first=0; else echo "," >> "$JSON"; fi
            echo "$entry" >> "$JSON"
          done

          echo "]" >> "$JSON"

          echo "" | tee -a "$LOG"
          echo "=== SUMMARY ===" | tee -a "$LOG"
          echo "OK=$ok" | tee -a "$LOG"
          echo "NOT_DEPLOYED=$not_deployed" | tee -a "$LOG"
          echo "BOOT_ERROR=$boot_error" | tee -a "$LOG"
          echo "CORS_WARNING=$cors_warn" | tee -a "$LOG"
          echo "CORS_404=$cors_404" | tee -a "$LOG"
          echo "CONNECTION_FAILED=$conn_failed" | tee -a "$LOG"
          echo "JSON=$JSON" | tee -a "$LOG"

          echo "AUDIT_JSON=$JSON" >> $GITHUB_ENV
          echo "AUDIT_LOG=$LOG" >> $GITHUB_ENV

          # Fail conditions
          if [ "${FAIL_ON_404}" = "true" ] && [ "$not_deployed" -gt 0 ]; then
            echo "::error::Full audit found NOT_DEPLOYED functions: $not_deployed"
            exit 1
          fi

          if [ "${FAIL_ON_BOOT}" = "true" ] && [ "$boot_error" -gt 0 ]; then
            echo "::error::Full audit found BOOT_ERROR functions: $boot_error"
            exit 1
          fi

          echo "âœ… Full audit completed (no blocking failures)."

      - name: Upload audit artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: functions-full-audit
          path: audit_out/
          retention-days: 14
